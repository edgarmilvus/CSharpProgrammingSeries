
/*
#
# These sources are part of the "C# Programming Series" by Edgar Milvus, 
# for additional info, new volumes, link to stores:
# https://github.com/edgarmilvus/CSharpProgrammingSeries
#
# MIT License
# Copyright (c) 2026 Edgar Milvus
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
*/

// Source File: project_advanced_application_script.cs
// Description: Advanced Application Script
// ==========================================

using System;

// ------------------------------------------------------------
// PROBLEM CONTEXT: AI Chatbot System - Message History Management
// ------------------------------------------------------------
// In a production AI chatbot, we need to store and process chat messages.
// Each message must be immutable to ensure thread-safety when multiple
// AI agents or background services access the history simultaneously.
// We need to enforce strict typing for different message types (User, AI, System)
// and calculate metadata like timestamps and token counts dynamically.
//
// This script demonstrates a generic Record-based architecture for managing
// immutable chat history with type-safe message payloads.
// ------------------------------------------------------------

namespace AdvancedOOP.DataStructures
{
    // ------------------------------------------------------------
    // 1. ENUM: Message Type Definition
    // ------------------------------------------------------------
    // Defines the allowed categories of messages in our chat system.
    // Using an enum ensures we don't have invalid string types floating around.
    public enum MessageType
    {
        User,      // Input from the human user
        AI,        // Response generated by the AI model
        System,    // Internal system notifications or errors
        Function   // Result of a tool/function call
    }

    // ------------------------------------------------------------
    // 2. RECORD: ChatMessage<T> - The Immutable Data Structure
    // ------------------------------------------------------------
    // We use a generic Record here. Generics allow us to enforce
    // type safety on the payload (T). For example, a User message
    // might have a string payload, while a Function message might
    // have a complex object payload.
    //
    // Why Record over Class?
    // 1. Immutability: Records are immutable by default. Once created,
    //    the data cannot be changed. This prevents accidental modification
    //    of chat history logs.
    // 2. Value Equality: Records compare by value, not reference.
    //    Two messages with the same data are considered equal.
    // 3. Concise Syntax: The primary constructor syntax reduces boilerplate.
    //
    // Constraints:
    // - T: The type of the message content.
    // - We explicitly forbid Lambda expressions and LINQ, so we will
    //   calculate metadata using standard methods and loops.
    public record ChatMessage<T>(MessageType Type, T Content, DateTime Timestamp)
    {
        // ------------------------------------------------------------
        // 3. COMPUTED PROPERTY: TokenCount
        // ------------------------------------------------------------
        // Since Records are immutable, we cannot set properties after creation.
        // However, we can have computed properties that derive values from
        // the constructor arguments.
        //
        // Logic: If the content is a string, we estimate tokens by splitting
        // by spaces. This is a naive implementation for demonstration purposes.
        public int TokenCount
        {
            get
            {
                // We must check if T is actually a string.
                // Since we can't use 'is' pattern matching in a property getter
                // easily without older syntax, we check the type.
                if (typeof(T) == typeof(string))
                {
                    string text = Content as string;
                    if (text == null) return 0;

                    // Forbidden: Lambda/LINQ (e.g., text.Split(' ').Length)
                    // We must manually count spaces or words.
                    int count = 0;
                    bool inWord = false;

                    // Manual loop to count words (tokens)
                    for (int i = 0; i < text.Length; i++)
                    {
                        if (text[i] != ' ')
                        {
                            if (!inWord)
                            {
                                count++;
                                inWord = true;
                            }
                        }
                        else
                        {
                            inWord = false;
                        }
                    }
                    return count;
                }
                return 0; // Non-string types have 0 tokens in this simple model
            }
        }

        // ------------------------------------------------------------
        // 4. METHOD: GetFormattedDisplay
        // ------------------------------------------------------------
        // Returns a formatted string representation of the message.
        // Demonstrates pattern matching (switch expression is not allowed,
        // so we use if-else chains).
        public string GetFormattedDisplay()
        {
            string typeLabel = "";
            
            // Pattern matching via if-else chains
            if (this.Type == MessageType.User)
            {
                typeLabel = "[USER]";
            }
            else if (this.Type == MessageType.AI)
            {
                typeLabel = "[AI]";
            }
            else if (this.Type == MessageType.System)
            {
                typeLabel = "[SYS]";
            }
            else if (this.Type == MessageType.Function)
            {
                typeLabel = "[FUNC]";
            }

            // Formatting the timestamp
            string timeStr = this.Timestamp.ToString("HH:mm:ss");

            // We need to convert Content to string safely.
            string contentStr = this.Content?.ToString() ?? "(Empty)";

            return $"{timeStr} {typeLabel}: {contentStr}";
        }
    }

    // ------------------------------------------------------------
    // 5. CLASS: ChatHistoryManager
    // ------------------------------------------------------------
    // Manages a collection of chat messages.
    // Note: We cannot use Lists or Arrays easily in a beginner context
    // without generic collections, but since we are in Book 2 (Intermediate),
    // we will use a simple array with a fixed size to demonstrate
    // memory management and manual iteration.
    public class ChatHistoryManager
    {
        // Fixed size array for simplicity (avoiding dynamic List<T> for strict beginner control)
        private ChatMessage<object>[] _messages;
        private int _currentCount;

        public ChatHistoryManager(int capacity)
        {
            _messages = new ChatMessage<object>[capacity];
            _currentCount = 0;
        }

        // ------------------------------------------------------------
        // 6. METHOD: AddMessage
        // ------------------------------------------------------------
        // Adds a new immutable message to the history.
        // We convert the generic message to a non-generic storage type (object)
        // for the array, but we retain the type information in the record itself.
        public void AddMessage<T>(MessageType type, T content)
        {
            if (_currentCount >= _messages.Length)
            {
                // In a real system, we might implement a circular buffer.
                // Here, we just throw an error for simplicity.
                throw new InvalidOperationException("Chat history capacity reached.");
            }

            // Create the immutable record
            var message = new ChatMessage<T>(type, content, DateTime.Now);

            // Store it in our array (boxing occurs here if T is a value type, 
            // but for chat strings it's fine).
            // We cast the generic record to the non-generic storage type.
            _messages[_currentCount] = message;
            _currentCount++;
        }

        // ------------------------------------------------------------
        // 7. METHOD: PrintHistory
        // ------------------------------------------------------------
        // Iterates through the history and prints formatted messages.
        // Demonstrates manual iteration (forbidden: foreach is often considered
        // syntactic sugar for IEnumerable/LINQ, so we use a standard for loop).
        public void PrintHistory()
        {
            Console.WriteLine("--- Chat History ---");
            
            // Manual loop
            for (int i = 0; i < _currentCount; i++)
            {
                ChatMessage<object> msg = _messages[i];
                
                // We can still access the generic methods via the stored object
                // because the record structure is preserved.
                Console.WriteLine(msg.GetFormattedDisplay());
                
                // Display token count
                Console.WriteLine($"   [Metadata: {msg.TokenCount} tokens]");
            }
            Console.WriteLine("--------------------");
        }

        // ------------------------------------------------------------
        // 8. METHOD: GetSummary
        // ------------------------------------------------------------
        // Calculates a summary of the history without using LINQ.
        // Returns a tuple containing total messages and total tokens.
        public (int TotalMessages, int TotalTokens) GetSummary()
        {
            int totalTokens = 0;
            
            for (int i = 0; i < _currentCount; i++)
            {
                totalTokens += _messages[i].TokenCount;
            }

            return (_currentCount, totalTokens);
        }
    }

    // ------------------------------------------------------------
    // 9. MAIN PROGRAM EXECUTION
    // ------------------------------------------------------------
    class Program
    {
        static void Main(string[] args)
        {
            // Initialize the history manager with a capacity of 10
            ChatHistoryManager history = new ChatHistoryManager(10);

            // 1. Add a System message (String payload)
            history.AddMessage(MessageType.System, "System initialized. Loading models...");

            // 2. Add a User message (String payload)
            history.AddMessage(MessageType.User, "Hello, can you explain Records in C#?");

            // 3. Add an AI response (String payload)
            history.AddMessage(MessageType.AI, "Records are immutable data types introduced in C# 9. They provide value-based equality.");

            // 4. Add a Function call result (String payload for simplicity)
            history.AddMessage(MessageType.Function, "GetWeather(Temperature: 72F)");

            // 5. Print the history
            // This demonstrates the immutability: we cannot change the messages
            // once added, only read them.
            history.PrintHistory();

            // 6. Get Summary Statistics
            var summary = history.GetSummary();
            Console.WriteLine($"Summary: {summary.TotalMessages} messages, {summary.TotalTokens} tokens estimated.");

            // ------------------------------------------------------------
            // EXPLANATION OF ARCHITECTURE
            // ------------------------------------------------------------
            // 1. IMMUTABILITY: Notice that ChatMessage<T> has no setters.
            //    If we tried to do `msg.Content = "New text"`, it would fail at compile time.
            //    This guarantees that the chat log is a permanent, unchangeable record.
            //
            // 2. GENERICS: We used <T> to allow different payload types in the future.
            //    Currently, we used strings, but we could easily swap in a JSON object
            //    or a specific data structure without changing the Record definition.
            //
            // 3. PATTERN MATCHING: In GetFormattedDisplay(), we used if-else chains
            //    to determine the label. This is explicit and easy to debug.
            //
            // 4. PERFORMANCE: Records are generally faster for equality checks than Classes.
            //    In a chat system, we might want to check if a message has already been
            //    processed (deduplication). Records make this trivial.
            //
            // 5. EXTENSIBILITY: The ChatHistoryManager uses a fixed array.
            //    In a real-world scenario, we would wrap this in a circular buffer
            //    or use a List<T> to handle dynamic resizing, but the logic for
            //    iterating and processing remains the same.
            // ------------------------------------------------------------
        }
    }
}
