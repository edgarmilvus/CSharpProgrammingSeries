
/*
#
# These sources are part of the "C# Programming Series" by Edgar Milvus, 
# for additional info, new volumes, link to stores:
# https://github.com/edgarmilvus/CSharpProgrammingSeries
#
# MIT License
# Copyright (c) 2026 Edgar Milvus
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
*/

// Source File: project_advanced_application_script.cs
// Description: Advanced Application Script
// ==========================================

using Microsoft.EntityFrameworkCore;
using Npgsql;
using System;
using System.Collections.Generic;
using System.Linq;

// Application Context: A specialized academic research library system.
// Problem: Researchers often struggle to find relevant papers based on semantic meaning
// rather than just keyword matching. For instance, searching for "neural network optimization"
// should also retrieve papers discussing "gradient descent improvements" or "backpropagation tuning".
// Solution: We implement a hybrid search engine using PostgreSQL with the pgvector extension.
// This allows us to store vector embeddings of paper abstracts and perform similarity searches
// combined with traditional SQL filters (e.g., publication year).

namespace AdvancedVectorSearch
{
    // ---------------------------------------------------------
    // 1. DATA MODEL
    // ---------------------------------------------------------
    // We define a simple entity to represent a research paper.
    // We use an array of floats to represent the vector embedding.
    // In a real scenario, these vectors would be generated by an AI model (e.g., OpenAI embeddings).
    public class ResearchPaper
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public int Year { get; set; }
        
        // This array maps to the 'vector(384)' column in PostgreSQL via pgvector.
        // We assume a dimension of 384 (common for smaller embedding models like all-MiniLM-L6-v2).
        public float[] Embedding { get; set; }
    }

    // ---------------------------------------------------------
    // 2. DATABASE CONTEXT
    // ---------------------------------------------------------
    // The DbContext manages the connection and mapping to the database.
    public class LibraryContext : DbContext
    {
        public DbSet<ResearchPaper> Papers { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            // Connection string to a PostgreSQL database with pgvector installed.
            // Ensure the database has the extension enabled: `CREATE EXTENSION vector;`
            optionsBuilder.UseNpgsql("Host=localhost;Database=library_db;Username=postgres;Password=your_password");
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure the entity to use the vector type provided by pgvector.
            modelBuilder.Entity<ResearchPaper>()
                .Property(p => p.Embedding)
                .HasColumnType("vector(384)"); // Must match the dimension of your embeddings
        }
    }

    // ---------------------------------------------------------
    // 3. CORE LOGIC: SEARCH ENGINE
    // ---------------------------------------------------------
    public class SearchEngine
    {
        // This method performs a hybrid search.
        // It combines:
        // 1. Semantic Search: Cosine similarity between query vector and stored vectors.
        // 2. Metadata Filter: SQL filtering (e.g., specific year).
        public List<ResearchPaper> HybridSearch(float[] queryVector, int? filterYear = null)
        {
            using (var context = new LibraryContext())
            {
                // We cannot use LINQ lambdas here as per constraints, 
                // so we construct a raw SQL query with parameters.
                // The query calculates the cosine distance and orders by relevance.
                string sql = @"
                    SELECT ""Id"", ""Title"", ""Year"", ""Embedding""
                    FROM ""Papers""
                    WHERE 1=1";

                // Dynamic SQL construction using basic control flow
                var parameters = new List<NpgsqlParameter>();
                parameters.Add(new NpgsqlParameter("@query_vector", queryVector));

                if (filterYear.HasValue)
                {
                    sql += " AND \"Year\" = @year";
                    parameters.Add(new NpgsqlParameter("@year", filterYear.Value));
                }

                // pgvector syntax: <=> operator returns cosine distance (0 to 2, where 0 is identical).
                // We order by this distance to get the most similar results first.
                sql += " ORDER BY \"Embedding\" <=> @query_vector LIMIT 10;";

                // Execute the raw SQL query
                var papers = context.Papers
                    .FromSqlRaw(sql, parameters.ToArray())
                    .ToList();

                return papers;
            }
        }

        // Helper method to calculate cosine similarity manually (for demonstration if needed)
        // Note: In production, rely on the database operator '<=>' for performance.
        public double CalculateCosineSimilarity(float[] vecA, float[] vecB)
        {
            if (vecA.Length != vecB.Length)
                throw new ArgumentException("Vectors must be of the same dimension.");

            double dotProduct = 0.0;
            double normA = 0.0;
            double normB = 0.0;

            for (int i = 0; i < vecA.Length; i++)
            {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }

            return dotProduct / (Math.Sqrt(normA) * Math.Sqrt(normB));
        }
    }

    // ---------------------------------------------------------
    // 4. MAIN PROGRAM EXECUTION
    // ---------------------------------------------------------
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Initializing Academic Research Library Search...");

            // 1. Setup: Ensure database exists and seeded (Mocking data for this example)
            // In a real app, we would check connectivity and run migrations.
            InitializeDatabase();

            // 2. Define a Search Query
            // We simulate a query vector. In reality, this comes from an embedding API.
            // This vector represents the semantic meaning of "Deep learning optimization techniques".
            float[] queryVector = new float[384];
            // Populating with dummy data for demonstration (usually random or AI-generated)
            for (int i = 0; i < 384; i++) queryVector[i] = 0.1f; 

            // 3. Execute Hybrid Search
            // We search for papers semantically similar to the query, filtered by year 2023.
            var engine = new SearchEngine();
            
            Console.WriteLine("\nExecuting Hybrid Search (Semantic + Year Filter)...");
            var results = engine.HybridSearch(queryVector, filterYear: 2023);

            // 4. Display Results
            if (results.Count == 0)
            {
                Console.WriteLine("No papers found matching the criteria.");
            }
            else
            {
                Console.WriteLine($"Found {results.Count} papers:");
                Console.WriteLine(new string('-', 50));
                foreach (var paper in results)
                {
                    // Calculate similarity score locally for display purposes
                    double similarity = engine.CalculateCosineSimilarity(queryVector, paper.Embedding);
                    
                    Console.WriteLine($"ID: {paper.Id}");
                    Console.WriteLine($"Title: {paper.Title}");
                    Console.WriteLine($"Year: {paper.Year}");
                    Console.WriteLine($"Similarity Score: {similarity:F4}");
                    Console.WriteLine(new string('-', 20));
                }
            }

            Console.WriteLine("\nSearch Complete.");
        }

        // Mock initialization to ensure the code runs conceptually
        static void InitializeDatabase()
        {
            // In a real scenario:
            // 1. context.Database.EnsureCreated();
            // 2. Seed data if empty.
            Console.WriteLine("Database connection verified.");
        }
    }
}
