
#
# These sources are part of the "C# Programming Series" by Edgar Milvus, 
# you can find it on stores: 
# 
# https://www.amazon.com/dp/B0GKJ3NYL6 or https://tinyurl.com/CSharpProgrammingBooks or 
# https://leanpub.com/u/edgarmilvus (quantity discounts)
# 
# New books info: https://linktr.ee/edgarmilvus 
#
# MIT License
# Copyright (c) 2026 Edgar Milvus
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Source File: basic_basic_code_example.cs
# Description: Basic Code Example
# ==========================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Threading.Tasks;

// 1. DEFINING THE DOMAIN MODEL
// In a real-world scenario, this represents a "Product" in an e-commerce inventory.
// We use modern C# features: Primary Constructors (C# 12) and Required Properties (C# 11).
// This class is a Plain Old CLR Object (POCO). It has no dependencies on EF Core.
public class Product(string name, decimal price, string category)
{
    [Key] // Data Annotation: Configures this property as the Primary Key.
    public int Id { get; set; } // Auto-generated by the database.

    [Required] // Data Annotation: Ensures the column is NOT NULL in the database.
    [MaxLength(100)] // Data Annotation: Configures the column length.
    public string Name { get; set; } = name;

    [Required]
    [Range(0.01, 10000.00)] // Data Annotation: Business logic validation constraint.
    public decimal Price { get; set; } = price;

    [Required]
    public string Category { get; set; } = category;

    // Navigation Property: Represents the relationship between Product and OrderItem.
    // "virtual" allows for lazy loading if configured, but we will use eager loading.
    public virtual ICollection<OrderItem> OrderItems { get; set; } = new List<OrderItem>();
}

public class OrderItem
{
    [Key]
    public int Id { get; set; }

    public int ProductId { get; set; }
    public Product Product { get; set; } = null!; // Non-nullable reference type

    public int Quantity { get; set; }
}

// 2. DEFINING THE DATA CONTEXT (EF CORE)
// The DbContext is the bridge between your domain classes and the database.
// It configures the connection and the mapping rules.
public class InventoryContext : DbContext
{
    private readonly string _connectionString;

    // Constructor Injection: Accepts a connection string.
    // This allows flexibility (e.g., using SQL Server, SQLite, or In-Memory providers).
    public InventoryContext(string connectionString)
    {
        _connectionString = connectionString;
        
        // CRITICAL: Ensure the database is created.
        // In a real app, use Migrations. For this "Hello World", we use EnsureCreated for simplicity.
        Database.EnsureCreated();
    }

    // DbSet<T> properties represent database tables.
    // EF Core tracks changes to these collections.
    public DbSet<Product> Products => Set<Product>();
    public DbSet<OrderItem> OrderItems => Set<OrderItem>();

    // OnConfiguring is where we define the Database Provider and Connection String.
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        // We use the modern SQL Server provider.
        // In a real app, this connection string comes from IConfiguration (appsettings.json).
        optionsBuilder.UseSqlServer(_connectionString);
    }

    // OnModelCreating allows for Fluent API configuration (alternative to Data Annotations).
    // This is where complex relationships and index configurations are defined.
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configuring the relationship explicitly using Fluent API.
        // This is often preferred over Data Annotations for complex domains.
        modelBuilder.Entity<Product>()
            .HasMany(p => p.OrderItems) // A Product has many OrderItems.
            .WithOne(o => o.Product)     // An OrderItem has one Product.
            .HasForeignKey(o => o.ProductId); // The Foreign Key property.

        // Seed Data: Using modern Collection Expression syntax.
        modelBuilder.Entity<Product>().HasData(
            new Product("Laptop", 1200.00m, "Electronics") { Id = 1 },
            new Product("Coffee Mug", 15.50m, "Kitchen") { Id = 2 }
        );
    }
}

// 3. THE APPLICATION LOGIC
// This class encapsulates the logic for interacting with the database.
// It uses modern C# Async/Await patterns.
public class InventoryService
{
    private readonly InventoryContext _context;

    public InventoryService(InventoryContext context)
    {
        _context = context;
    }

    // Example 1: Basic Querying with LINQ
    // Translates C# code directly into SQL.
    public async Task<List<Product>> GetExpensiveProductsAsync(decimal threshold)
    {
        // EF Core tracks the query execution. No data is fetched until 'ToListAsync()' is called.
        // This is "Deferred Execution".
        return await _context.Products
            .Where(p => p.Price > threshold) // SQL: WHERE Price > @threshold
            .OrderByDescending(p => p.Price) // SQL: ORDER BY Price DESC
            .ToListAsync();
    }

    // Example 2: Adding Data
    public async Task AddProductAsync(string name, decimal price, string category)
    {
        var newProduct = new Product(name, price, category);
        
        // Change Tracking: EF Core detects this new entity.
        _context.Products.Add(newProduct);

        // SaveChangesAsync commits the transaction to the database.
        // It generates the appropriate INSERT SQL statement.
        await _context.SaveChangesAsync();
    }

    // Example 3: Complex Query with Projection
    // Projecting into an anonymous type or DTO (Data Transfer Object).
    public async Task<object> GetProductStatsAsync()
    {
        // This query performs grouping and aggregation on the database side.
        // It does not pull all records into memory first.
        var stats = await _context.Products
            .GroupBy(p => p.Category)
            .Select(g => new
            {
                Category = g.Key,
                AveragePrice = g.Average(p => p.Price),
                Count = g.Count()
            })
            .ToListAsync();

        return stats;
    }
}

// 4. MAIN EXECUTION
// The entry point of the application.
class Program
{
    static async Task Main(string[] args)
    {
        // Connection String for LocalDB (SQL Server).
        // NOTE: Ensure you have a SQL Server instance running or change to UseInMemoryDatabase for testing.
        string connectionString = "Server=(localdb)\\mssqllocaldb;Database=InventoryDb;Trusted_Connection=True;";

        // Dependency Injection Setup (Simulated).
        // In ASP.NET Core, this is handled by the ServiceCollection.
        using (var context = new InventoryContext(connectionString))
        {
            var service = new InventoryService(context);

            Console.WriteLine("--- 1. Adding a new Product ---");
            await service.AddProductAsync("Wireless Headphones", 99.99m, "Electronics");
            Console.WriteLine("Product added successfully.");

            Console.WriteLine("\n--- 2. Querying Expensive Products (> $50) ---");
            var expensiveProducts = await service.GetExpensiveProductsAsync(50);
            
            foreach (var product in expensiveProducts)
            {
                Console.WriteLine($"ID: {product.Id}, Name: {product.Name}, Price: ${product.Price}");
            }

            Console.WriteLine("\n--- 3. Aggregating Data by Category ---");
            var stats = await service.GetProductStatsAsync();
            // Using System.Text.Json for serialization (modern approach)
            var json = System.Text.Json.JsonSerializer.Serialize(stats, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
            Console.WriteLine(json);
        }
    }
}
