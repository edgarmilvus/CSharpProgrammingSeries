
/*
#
# These sources are part of the "C# Programming Series" by Edgar Milvus, 
# for additional info, new volumes, link to stores:
# https://github.com/edgarmilvus/CSharpProgrammingSeries
#
# MIT License
# Copyright (c) 2026 Edgar Milvus
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
*/

// Source File: basic_basic_code_example.cs
// Description: Basic Code Example
// ==========================================

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Numerics;

// 1. Define the Entity
// Represents a document chunk with an embedding vector for semantic search.
public class DocumentChunk
{
    [Key]
    public int Id { get; set; }

    [MaxLength(500)]
    public string Content { get; set; } = string.Empty;

    // The vector property. We use float[] for compatibility with most vector databases.
    // In a production scenario, this would be generated by an AI model (e.g., OpenAI embeddings).
    [Column(TypeName = "vector(384)")] // Specific to pgvector extension in PostgreSQL
    public float[] Embedding { get; set; } = Array.Empty<float>();
}

// 2. Define the DbContext
public class RagContext : DbContext
{
    public DbSet<DocumentChunk> DocumentChunks { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        // Using PostgreSQL with the pgvector extension.
        // Ensure you have installed the Npgsql.EntityFrameworkCore.PostgreSQL and Npgsql.EntityFrameworkCore.PostgreSQL.Vector packages.
        optionsBuilder
            .UseNpgsql("Host=localhost;Database=RagDemo;Username=postgres;Password=your_password")
            .UseLoggerFactory(LoggerFactory.Create(builder => builder.AddConsole()));
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<DocumentChunk>(entity =>
        {
            // CRITICAL: Define the vector index to accelerate similarity search.
            // HNSW (Hierarchical Navigable Small World) is the state-of-the-art algorithm
            // for approximate nearest neighbor search, offering high speed and recall.
            // We are indexing the 'Embedding' column using the L2 (Euclidean) distance metric.
            entity.HasIndex(e => e.Embedding)
                  .HasMethod("hnsw") 
                  .HasOperators("vector_cosine_ops"); // or 'vector_l2_ops' depending on your distance metric
        });
    }
}

// 3. The Application Logic (Hello World)
public class Program
{
    public static async Task Main(string[] args)
    {
        // Setup the database
        await using var context = new RagContext();
        
        // Ensure the database is created and migrations are applied.
        // Note: You must have the pgvector extension enabled in your database:
        // CREATE EXTENSION IF NOT EXISTS vector;
        await context.Database.EnsureCreatedAsync();

        // Seed some dummy data
        await SeedDataAsync(context);

        // The Search Query: Find the chunk most similar to "Machine Learning concepts"
        var queryEmbedding = new float[384]; 
        // In reality, fill this with actual vector data. Here we simulate it.
        Random.Shared.NextBytes(queryEmbedding); // Simulating a vector
        
        Console.WriteLine("Searching for semantically similar documents...");

        // THE CORE QUERY: Using Vector Distance for Similarity Search
        // We calculate the cosine distance between the query vector and stored embeddings.
        // Lower distance implies higher similarity (0 = identical, 2 = opposite).
        var results = await context.DocumentChunks
            .Select(c => new 
            {
                c.Content,
                // Calculate the distance on the fly. 
                // Note: 'vector_cosine_ops' index optimizes this specific calculation.
                Distance = EF.Functions.VectorCosineDistance(c.Embedding, queryEmbedding)
            })
            .OrderBy(x => x.Distance) // Find the closest matches
            .Take(3)
            .ToListAsync();

        // Output results
        Console.WriteLine("\nTop 3 Matches:");
        foreach (var result in results)
        {
            Console.WriteLine($"- Content: {result.Content}");
            Console.WriteLine($"  Distance: {result.Distance:F4}"); // 0.0 is perfect match
        }
    }

    private static async Task SeedDataAsync(RagContext context)
    {
        if (await context.DocumentChunks.AnyAsync()) return;

        // Simulated embeddings (384 dimensions) for demonstration
        var chunk1 = new DocumentChunk 
        { 
            Content = "Introduction to Neural Networks", 
            Embedding = CreateMockVector(0.1f) 
        };
        var chunk2 = new DocumentChunk 
        { 
            Content = "Advanced Calculus and Linear Algebra", 
            Embedding = CreateMockVector(0.5f) 
        };
        var chunk3 = new DocumentChunk 
        { 
            Content = "Machine Learning Fundamentals", 
            Embedding = CreateMockVector(0.15f) // Close to chunk1
        };

        context.DocumentChunks.AddRange(chunk1, chunk2, chunk3);
        await context.SaveChangesAsync();
    }

    // Helper to generate deterministic mock vectors for the example
    private static float[] CreateMockVector(float offset)
    {
        var vector = new float[384];
        for (int i = 0; i < vector.Length; i++)
        {
            vector[i] = (float)Math.Sin(i * 0.1 + offset);
        }
        return vector;
    }
}
